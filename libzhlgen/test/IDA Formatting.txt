In order to use the header files generated by IDA in conjunction with libzhl, there are particular conventions that need to be respected (some of them are pretty weird since this wasn't really intended to be public but I'm sure you'll get used to them).

First of all, only structs are supported, typedefs and enums will be ignored and you'll need to manually add those to Global.zhl.
To minimize potential issues, delete every struct you never use (IDA will automatically generate structs with some EXEs, you usually don't want to keep those around).

** Nested classes/namespaces

Whenever you'd normally use :: (i.e. std::string), use __ instead (std__string). This is because some versions of IDA act weird when struct names contain "invalid" characters. The parsefuncs tool will parse the double underscore and process it accordingly.
Namespaces aren't actually supported yet, with std being the only exception.
Also note that structs from the std namespace will not be declared in the generated file, it is your responsibility to include the proper header files in Global.zhl and ensure that you're using the same standard library as the program you're hooking into.

** Templates

Things get a bit uglier when templates are involved and you can skip this part for now if your disassembly doesn't involve template classes yet.
Here's how to translate std::map<std::string, int*>:
	- Take the contents between the < > brackets and replace all commas with triple underscores ___
		std::string___int*
	- Since the second template argument is a pointer type, replace the asterisk with Z1 (if there are two asterisks, write Z2 instead of Z1 and so on)
		std::string___intZ1
	- Replace :: with __ as usual
		std__string___intZ1
	- Now count the number of characters in the name you've obtained, then insert a single underscore followed by that number at the beginning
		_19std__string___intZ1
	- Finally, replace the :: from std::map with __ and insert that at the beginning
		std__map_19std__string___intZ1

The same process applies to nested templates such as std::vector<std::map<std::string, int*>>, start from the inside and then work your way out. You should end up with this:
	std__vector_30std__map_19std__string___intZ1

While this really doesn't look great, it is considered a valid class name by IDA and will be reliably demangled by parsefunc.

** Subclassing

If you have two structs named, for instance, BaseEntity and Player, with the first member of Player being an instance of BaseEntity named _base, parsefuncs will derive Player from BaseEntity in the generated header file.

** Virtual functions

If the first member of a struct is named _vtable and is a pointer to a structure named VTable_ followed by the name of that struct (i.e. Entity -> VTable_Entity), then that member will not be written to the header file.
Instead, the contents of the vtable will be written to the struct definition as a series of virtual functions. Those functions must be declared as virtual in the corresponding .zhl file if they are sigscanned.

The first entry in a vtable is often a virtual destructor. If that entry is named "Free", it will appear as a virtual destructor in the generated header file instead of a virtual function named "Free".

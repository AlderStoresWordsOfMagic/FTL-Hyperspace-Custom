"f30f10442404f30f1101f30f10442408f30f114104c20800908db426000000005589e583ec04f30f1009f30f104104f30f5c4d08f30f5c450cf30f59c9f30f59c0f30f58c1f30f110424":
void Pointf::constructor(Pointf *this<ecx>, float x, float y);

struct Pointf {{
	Pointf() : x(0.f), y(0.f) {}
	Pointf(float _x, float _y) : x(_x), y(_y) {}
	Pointf(const Pointf &v) : x(v.x), y(v.y) {}
	
	static Pointf FromAngle(float a) {return Pointf((float)cos((double)a*0.01745329238474369), (float)sin((double)a*0.01745329238474369));}
	
	static Pointf FromDirection(int dir)
	{
		static const Pointf dirs[] = {
			Pointf(-1.f, 0.f),
			Pointf(0.f, -1.f),
			Pointf(1.f, 0.f),
			Pointf(0.f, 1.f)
		};
		
		if(dir < 0 || dir >= 4)
			return Pointf();
		else
			return dirs[dir];
	}
	
	Pointf &operator=(const Pointf &v) {x=v.x; y=v.y; return *this;}
	Pointf &operator+=(const Pointf &v) {x+=v.x; y+=v.y; return *this;}
	Pointf &operator-=(const Pointf &v) {x-=v.x; y-=v.y; return *this;}
	Pointf &operator*=(const Pointf &v) {x*=v.x; y*=v.y; return *this;}
	Pointf &operator/=(const Pointf &v) {x/=v.x; y/=v.y; return *this;}
	Pointf &operator*=(float f) {x*=f; y*=f; return *this;}
	Pointf &operator/=(float f) {x/=f; y/=f; return *this;}
	
	friend bool operator==(const Pointf &a, const Pointf &b) {return a.x==b.x && a.y==b.y;}
	friend bool operator!=(const Pointf &a, const Pointf &b) {return a.x!=b.x || a.y!=b.y;}
	
	Pointf operator-() const {return Pointf(-x, -y);}
	friend Pointf operator+(const Pointf &a, const Pointf &b) {return Pointf(a.x+b.x, a.y+b.y);}
	friend Pointf operator-(const Pointf &a, const Pointf &b) {return Pointf(a.x-b.x, a.y-b.y);}
	friend Pointf operator*(const Pointf &a, const Pointf &b) {return Pointf(a.x*b.x, a.y*b.y);}
	friend Pointf operator/(const Pointf &a, const Pointf &b) {return Pointf(a.x/b.x, a.y/b.y);}
	friend Pointf operator*(const Pointf &a, float f) {return Pointf(a.x*f, a.y*f);}
	friend Pointf operator*(float f, const Pointf &a) {return Pointf(a.x*f, a.y*f);}
	friend Pointf operator/(const Pointf &a, float f) {return Pointf(a.x/f, a.y/f);}
	
	float Dot(const Pointf &v) const {return x*v.x + y*v.y;}
	float Angle() const {return (float)(atan2(y, x)/0.01745329238474369);}
	
	float LengthSqr() const {return x*x+y*y;}
	float Length() const {return sqrt(LengthSqr());}
	float DistanceSqr(Pointf v) const {return (v-=*this).LengthSqr();}
	float Distance(Pointf v) const {return (v-=*this).Length();}
	
	Pointf &Normalize(bool *ok = 0)
	{
		float d = Length();
		if(d > 0.f)
		{
			x/=d;
			y/=d;
			if(ok) *ok = true;
		}
		else
		{
			if(ok) *ok = false;
		}
		
		return *this;
	}
	
	Pointf GetNormalized(bool *ok = 0) const
	{
		return Pointf(*this).Normalize(ok);
	}
	
	Pointf &SetLength(float len, bool *ok = 0)
	{
		float d = Length();
		if(d > 0.f)
		{
			x*=len/d;
			y*=len/d;
			if(ok) *ok = true;
		}
		else
		{
			if(ok) *ok = false;
		}
		
		return *this;
	}
	
	Pointf &Rotate(float a)
	{
		float c = (float)cos((double)a*0.01745329238474369);
		float s = (float)sin((double)a*0.01745329238474369);
		float x0 = x;
		x = x*c - y*s;
		y = x0*s + y*c;
		return *this;
	}
	Pointf GetRotated(float a) const {return Pointf(*this).Rotate(a);}
	
	Pointf &AxisAlign()
	{
		if(x != 0.f || y != 0.f)
		{
			if(abs(y) >= abs(x))
			{
				x = 0.f;
				y = y > 0.f ? 1.f : -1.f;
			}
			else
			{
				y = 0.f;
				x = x > 0.f ? 1.f : -1.f;
			}
		}
		return *this;
	}
	Pointf GetAxisAligned() const {return Pointf(*this).AxisAlign();}
	
	static Pointf Lerp(float c, Pointf a, Pointf b)
	{
		return Pointf(
			(1.f-c)*a.x + c*b.x,
			(1.f-c)*a.y + c*b.y
		);
	}
}};